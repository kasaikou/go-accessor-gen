//go:generate goacc -i generator.go
package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"

	"github.com/kasaikou/goacc/goacc/entity"
	"github.com/kasaikou/goacc/goacc/parser"
	"golang.org/x/tools/imports"
)

func NewGenerator() *Generator {
	g := Generator{}
	g.goaccPreNewHook()
	return &g
}

type Generator struct {
	cache map[string]*entity.FileConfig `goacc:"json"`
}

func (g *Generator) goaccPreNewHook() {
	g.cache = make(map[string]*entity.FileConfig)
}

func (g *Generator) Generate(srcFilename string, generateConfig *entity.GenerateConfig) (destFilename string, b []byte, err error) {

	if !filepath.IsAbs(srcFilename) {
		srcFilename = filepath.Join(generateConfig.WorkingDir(), srcFilename)
	}

	config, exist := g.cache[srcFilename]
	if !exist {
		g.loadFile(srcFilename, generateConfig)
		config = g.cache[srcFilename]
	}

	buffer := bytes.NewBufferString("")
	fprintfln(buffer, "// Code generated by github.com/kasaikou/goacc, DO NOT EDIT.")
	fprintfln(buffer, "// defaultTag=%s", generateConfig.DefaultTag())
	fprintfln(buffer, "package %s", config.PackageName())
	fprintfln(buffer, "")

	emptyLength := buffer.Len()

	for _, structConfig := range config.Structs() {
		generateNew(buffer, structConfig)
		generateAccessor(buffer, structConfig)
		generateMarshalJSON(buffer, structConfig)
	}
	destFilename = RenameDestFilename(srcFilename)

	if buffer.Len() == emptyLength {
		return destFilename, nil, nil
	}

	b, err = format.Source(buffer.Bytes())
	if err != nil {
		return destFilename, nil, fmt.Errorf("%w: %w", entity.ErrFailedGoFmtCommand, err)
	}

	b, err = imports.Process(destFilename, b, nil)
	if err != nil {
		return destFilename, nil, fmt.Errorf("%w: %w", entity.ErrFailedGoImportsCommand, err)
	}

	return destFilename, b, nil
}

func (g *Generator) loadFile(srcFilename string, generateConfig *entity.GenerateConfig) error {
	dirname := filepath.Dir(srcFilename)
	pkg, err := parser.LoadPackage(parser.NewLoadPackageInputBuilder(
		dirname,
	).Build())
	if err != nil {
		return fmt.Errorf("cannot load file '%s': %w", srcFilename, err)
	}

	fileConfigs, err := parser.ParsePackage(
		parser.NewParsePackageInputBuilder(
			pkg,
			generateConfig.DefaultTag(),
		).Build(),
	)

	for _, file := range fileConfigs {
		g.cache[file.Filename()] = &file
	}

	if _, exist := g.cache[srcFilename]; !exist {
		panic("cannot cache: " + srcFilename)
	}

	return nil
}

func WriteFile(destFilename string, buffer []byte) error {
	if buffer == nil {
		return nil
	}

	file, err := os.Create(destFilename)
	if err != nil {
		return err
	}
	defer file.Close()

	if _, err := file.Write(buffer); err != nil {
		return err
	}

	return nil
}
